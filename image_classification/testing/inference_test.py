# -*- coding: utf-8 -*-
"""inference_test.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1beFLhjMu-oeodUsaahGkKsJZlk4Q0N_7
"""

import torch
import torch.nn as nn
from torchvision.transforms import transforms
from torch.autograd import Variable
from torchvision.models import squeezenet1_1
import requests
import shutil
from io import open, BytesIO
import os
from PIL import Image, ImageFile
import json

# Replace with my own model once I train it
"""
checkpoint = torch.load("pathtosavedmodel")
model = SimpleNet(num_classes=10)

model.load_state_dict(checkpoint)
model.eval()

If we're running prediction w a model trained on cifar10,
change transforms.CenterCrop(224) to transforms.Resize(32)
"""

model = squeezenet1_1(pretrained=True)
model.eval()

def predict_image(image_path):
    print('in predict_image image_path: {}'.format(image_path))

    image = Image.open(image_path)

    # Define transformations for the image, should (note that imagenet models are trained with image size 224)
    transformation = transforms.Compose([
        transforms.CenterCrop(224),
        transforms.ToTensor(),
        transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))

    ])

    # Preprocess the image
    image_tensor = transformation(image).float()

    # Add an extra batch dimension since pytorch treats all images as batches
    image_tensor = image_tensor.unsqueeze_(0)

    if torch.cuda.is_available():
        image_tensor.cuda()

    # Turn the input into a Variable
    input = Variable(image_tensor)

    # Predict the class of the image
    output = model(input)

    index = output.data.numpy().argmax()

    return index

if __name__ == "__main__":

    imagefile = "image.png"

    imagepath = os.path.join(os.getcwd(), imagefile)
#     # Download image if it doesn't exist
#     if not os.path.exists(imagepath):
#         data = requests.get(
#             "https://github.com/OlafenwaMoses/ImageAI/raw/master/images/3.jpg", stream=True)

#         with open(imagepath, "wb") as file:
#             shutil.copyfileobj(data.raw, file)

#         del data

    print('imagepath: {}'.format(imagepath))

    # Run prediction function and obtain predicted class index
    index = predict_image(imagepath)
    print('index: {}'.format(index))
    
    index_file = "imagenet_class_index.json"

    indexpath = os.path.join(os.getcwd(), index_file)
#     # Download class index if it doesn't exist
#     if not os.path.exists(indexpath):
#         data = requests.get('https://github.com/OlafenwaMoses/ImageAI/raw/master/imagenet_class_index.json')

#         with open(indexpath, "w", encoding="utf-8") as file:
#             file.write(data.text)

    print('indexpath: {}'.format(indexpath))
    class_map = json.load(open(indexpath))
    
    prediction = class_map[str(index)][1]

    print("Predicted Class ", prediction)